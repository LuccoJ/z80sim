#include <stdio.h>

#define MAX_STRING 256
#define MAX_NAME 64

#define OP_JP 0xC3

typedef enum {FALSE, TRUE} bool;

typedef unsigned char byte;

typedef unsigned int word; 

typedef struct {
	char Name[MAX_NAME];
	byte ID;
	word Address;
	char Prototype[MAX_STRING];
} funcdef;

funcdef Functions[256];
int FunctionsCount;

void Map(char* Name, word Address) {
	int i;
	for(i=0; i<FunctionsCount; i++) {
		if(!strcmp(Functions[i].Name, Name)) {
			Functions[i].Address=Address;
			return;
		}
	}
}

void SortFunctions() {
	funcdef Temp;
	bool Sorted;
	int i;
	do {
		Sorted=TRUE;
		for(i=1; i<FunctionsCount; i++) {
			if(Functions[i].ID<Functions[i-1].ID) {
				Temp=Functions[i];
				Functions[i]=Functions[i-1];
				Functions[i-1]=Temp;
				Sorted=FALSE;
			}
		}
	} while(!Sorted);
}

bool InString(char* String, char* Part) {
	int i, j;
	bool Found;
	if(strlen(Part)>strlen(String)) return FALSE;
	for(i=0; i<strlen(String); i++) {
		for(j=0; j<strlen(Part); j++) {
			Found=TRUE;
			if(Part[j]!=String[i+j]) {
				Found=FALSE;
				break;
			}
		}
		if(Found) return TRUE;
	}
	return FALSE;
}	

void GetPrototype(FILE* Handle, funcdef* Function) {
	char Line[MAX_STRING];
	int i;
	fseek(Handle, 0L, SEEK_SET);
	while(!feof(Handle)) {
		fgets(Line, MAX_STRING, Handle);
		if(InString(Line, Function->Name)) {
			for(i=strlen(Line)-1; i>=0; i--) {
				if(Line[i]==';') {
					Line[i]='\0';
					strcpy(Function->Prototype, Line);
					return;
				}
			}
		}
	}
	fprintf(stderr, "Prototype not found for function '%s'\n", Function->Name);
} 

void Syntax(char* ProgName) {
	fprintf(stderr, "Usage: %s [--jp] [--code <file.c>] --sym <file.sym> [-i|--input] <file.cls> [-o|--output] <file.o>\n", ProgName);
	fprintf(stderr, "Create a jump table for the C functions specified in the input file.\n");
	fprintf(stderr, "\nWhen file.cls is -, read standard input.\n");
	fprintf(stderr, "\nReport bugs to <ljlbox@tiscalinet.it>.\n");
} 

int main(int argc, char* argv[]) {
	FILE* MapFile=0;
	FILE* CallsFile=0;
	FILE* ObjFile=0;
	FILE* CodeFile=0;
	FILE* ProtoFile=0;
	char Line[MAX_STRING];
	char Name[MAX_NAME];
	char Command[MAX_NAME];
	char File[MAX_STRING];
	char AddressString[MAX_STRING];
	word Address;
	bool PrependJPs=FALSE;
	int i;

	if(argc>1) if(!strcmp(argv[1], "--help") || !strcmp(argv[1], "-h")) {
		Syntax(argv[0]);
		exit(0);
	}
	for(i=1; i<argc; i++) {
		if(!strcmp(argv[i], "--jp")) {
			PrependJPs=TRUE;
		} else if(!strcmp(argv[i], "--code") && i+1<argc) {
			CodeFile=fopen(argv[++i], "w");
		} else if((!strcmp(argv[i], "--input") || !strcmp(argv[i], "-i")) && i+1<argc) {
			if(!strcmp(argv[++i], "-")) {
				CallsFile=stdin;
			} else {
				CallsFile=fopen(argv[i], "r");
			}
		} else if(!strcmp(argv[i], "--sym")  && i+1<argc) {
			MapFile=fopen(argv[++i], "r");
		} else if((!strcmp(argv[i], "--obj") || !strcmp(argv[i], "-o")) && i+1<argc) {
			ObjFile=fopen(argv[++i], "w");
		}
	}
	if(!CallsFile || !MapFile || !ObjFile) {
		fprintf(stderr, "You must specify at least a valid input file, symbols file and object file\n");
		Syntax(argv[0]);
		exit(-1);
	}

	if(CodeFile) fprintf(stderr, "Will generate a C source with function wrappers.\n");

	fprintf(stderr, "Creating list of functions to be mapped...\n");

	FunctionsCount=0; while(!feof(CallsFile)) {
		fgets(Line, MAX_STRING, CallsFile);
		sscanf(Line, "%s", Command);
		if(!strcmp(Command, "prototypes")) {
			sscanf(Line, "%s %s", Command, File);
			if(ProtoFile) fclose(ProtoFile);
			if(!(ProtoFile=fopen(File, "r"))) {
				fprintf(stderr, "No such prototypes file '%s'.\n", File);
				exit(-1);
			}
		} else {
			sscanf(Line, "%x %s", &Functions[FunctionsCount].ID, Functions[FunctionsCount].Name);
			Functions[FunctionsCount].Address=0xFFFF;
			if(ProtoFile) GetPrototype(ProtoFile, &Functions[FunctionsCount]);
			if(!feof(CallsFile)) FunctionsCount++;
		}
	}

	fprintf(stderr, "Mapping functions...\n");

	while(!feof(MapFile)) {
		fgets(Line, MAX_STRING, MapFile);
		if(Line[0]!=';') {
			sscanf(Line, "%s %s", AddressString, Name);
                        sscanf(&AddressString[3], "%x", &Address);
			if(Name[0]=='_' && AddressString[2]==':') Map(&Name[1], Address);
		}
	}

	fprintf(stderr, "Sorting list...\n");

	SortFunctions();

	fprintf(stderr, "Generating output...\n\n");

	if(CodeFile) {
		fprintf(CodeFile, "/* Library source generated by funcmap\n   (Copyright (c) 2003 Lorenzo J. Lucchini, <ljlbox@tiscalinet.it>)\n\n   Every library function saves the address to resume userland execution from\n   into HL, then loads the system call number into A, and then makes the call\n   by means of a RST08 instruction. */\n\n\n");
		fprintf(CodeFile, "/* Declarations */\n\n");
		for(i=0; i<FunctionsCount; i++) {
			fprintf(CodeFile, "%s;\n", Functions[i].Prototype);
		}
		fprintf(CodeFile, "\n/* Definitions */ \n");
	}

	for(i=0; i<FunctionsCount; i++) {
		if(Functions[i].Address==0xFFFF) {
			fprintf(stderr, "Warning: Unmapped call %03d ('%s')\n", Functions[i].ID, Functions[i].Name);
		} else {
			if(CodeFile) {
				fprintf(CodeFile, "\n%s {\n", Functions[i].Prototype);
				fprintf(CodeFile, "    _asm\n    pop hl\n    ld a,#0x%02x\n    rst 0x08\n    _endasm;\n", Functions[i].ID);
				fprintf(CodeFile, "}\n");
			}
			fprintf(stdout, "Call %03d: '%s' at %04x\n", Functions[i].ID, Functions[i].Name, Functions[i].Address);
			if(PrependJPs) fprintf(ObjFile, "%c", OP_JP);
			fprintf(ObjFile, "%c%c", Functions[i].Address&0xff, (Functions[i].Address>>8)&0xff);
		}
	}
	fprintf(stdout, "\n");
	return 0;
}
